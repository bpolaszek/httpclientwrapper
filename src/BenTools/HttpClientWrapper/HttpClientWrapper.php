<?php
/**
 * HttpClientWrapper.php
 * Generated by PhpStorm - 11/2015
 *
 * @author Beno!t POLASZEK
 **/

namespace BenTools\HttpClientWrapper;

use GuzzleHttp\Client;
use GuzzleHttp\Exception\BadResponseException;
use GuzzleHttp\Pool;
use GuzzleHttp\Psr7\Response as PSR7Response;
use Symfony\Bridge\PsrHttpMessage\Factory\DiactorosFactory;
use Symfony\Bridge\PsrHttpMessage\Factory\HttpFoundationFactory;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Symfony\Component\HttpFoundation\Request;

class HttpClientWrapper {

    /**
     * @var Client
     */
    protected $client;

    /**
     * @var EventDispatcherInterface
     */
    protected $eventDispatcher;

    /**
     * @var DiactorosFactory
     */
    protected $psr7Factory;

    /**
     * @var HttpFoundationFactory
     */
    protected $httpFoundationFactory;

    /**
     * @var Promise[]
     */
    protected $promises = [];

    /**
     * HttpClientWrapper constructor.
     * @param EventDispatcherInterface $eventDispatcher
     */
    public function __construct(Client $client, EventDispatcherInterface $eventDispatcher) {
        $this->client          = $client;
        $this->eventDispatcher = $eventDispatcher;
    }

    /**
     * @param Request $request
     * @return Promise
     */
    public function sendASync(Request $request) {
        $requestId       = $this->getRequestFingerPrint($request);
        $eventDispatcher = $this->getEventDispatcher();
        $promise      = new Promise($this, $request, $requestId, $eventDispatcher);
        $this->promises[$requestId] = $promise;
        return $promise;
    }

    /**
     * @param int $buffer
     * @throws \Exception
     */
    public function flush($buffer = 10) {
        $psr7Requests    = [];
        $flushedPromises = [];

        foreach ($this->promises AS $requestId => $promise) {
            $event = $this->getEventDispatcher()->dispatch(sprintf('%s.BEFORE', $requestId), new RequestEvent($promise));
            if (!$event->isPropagationStopped() && $event->getResponse()) {
                $this->getEventDispatcher()->dispatch(sprintf('%s.SUCCESS', $requestId), new RequestEvent($promise, $event->getResponse()));
                $this->removePromise($requestId);
            }
        }

        # Transform our proprietary promises to PSR7-requests
        foreach ($this->promises AS $requestId => $promise)
            $psr7Requests[$requestId] = $this->fromHttpFoundationToPSR7($promise->getRequest());

        if ($this->promises) {

            # Create a pool of promises
            $pool = new Pool($this->client, $psr7Requests, [

                # How much promises can run at once
                'concurrency' => $buffer,

                # When a promise is fulfilled
                'fulfilled'   => function (PSR7Response $psr7Response, $index) use (&$flushedPromises) {
                    $promise   = $this->getPromiseByIndex($index);
                    $requestId = $promise->getRequestId();
                    $response  = $this->getHttpFoundationFactory()->createResponse($psr7Response);
                    $this->getEventDispatcher()->dispatch(sprintf('%s.SUCCESS', $requestId), new RequestEvent($promise, $response));
                    $flushedPromises[] = $requestId;
                },

                # When a promise is rejected
                'rejected'    => function (BadResponseException $exception, $index) use (&$flushedPromises) {
                    $promise      = $this->getPromiseByIndex($index);
                    $requestId    = $promise->getRequestId();
                    $psr7Response = $exception->getResponse();
                    $response     = $this->getHttpFoundationFactory()->createResponse($psr7Response);
                    $this->eventDispatcher->dispatch(sprintf('%s.ERROR', $requestId), new RequestEvent($promise, $response, $exception));
                    $flushedPromises[] = $requestId;
                },
            ]);

            # Initiate the transfers and create a promise
            $promise = $pool->promise();

            # Force the pool of requests to complete.
            $promise->wait();
        }

        # Remove promises from the pool
        foreach ($flushedPromises AS $requestId)
            $this->removePromise($requestId);

        # If new promises have been set during callbacks, flush again
        if ($this->promises)
            $this->flush($buffer);
    }

    /**
     * @param $index
     * @return Promise
     */
    public function getPromiseByIndex($index) {
        return array_key_exists($index, $this->promises) ? $this->promises[$index] : null;
    }

    /**
     * @param $requestId
     */
    public function removePromise($requestId) {
        if (array_key_exists($requestId, $this->promises))
            unset($this->promises[$requestId]);
    }

    /**
     * @return EventDispatcherInterface
     */
    public function getEventDispatcher() {
        return $this->eventDispatcher;
    }

    /**
     * @param EventDispatcherInterface $eventDispatcher
     * @return $this - Provides Fluent Interface
     */
    public function setEventDispatcher($eventDispatcher) {
        $this->eventDispatcher = $eventDispatcher;
        return $this;
    }

    /**
     * @param Request $request
     * @return \Psr\Http\Message\MessageInterface|\Psr\Http\Message\ServerRequestInterface|HttpClientWrapper|\Zend\Diactoros\ServerRequest
     */
    public function fromHttpFoundationToPSR7(Request $request) {
        switch ($request->getMethod()) {
            case 'POST':
                return $this->fromHttpFoundationPOSTToPSR7($request);
            case 'PUT':
                return $this->fromHttpFoundationPUTToPSR7($request);
            default:
                return $this->fromHttpFoundationGETToPSR7($request);
        }
    }

    /**
     * @param Request $request
     * @return \Psr\Http\Message\MessageInterface|\Zend\Diactoros\ServerRequest
     */
    public function fromHttpFoundationPOSTToPSR7(Request $request) {
        $psr7Request = $this->getPsr7Factory()->createRequest($request);
        $body        = \GuzzleHttp\Psr7\stream_for(http_build_query($request->request->all(), null, '&'));
        $psr7Request = $psr7Request->withBody($body);
        return $psr7Request;
    }

    /**
     * @param Request $request
     * @return \Psr\Http\Message\MessageInterface|\Zend\Diactoros\ServerRequest
     */
    public function fromHttpFoundationPUTToPSR7(Request $request) {
        $request->headers->set('Content-type', 'application/json');
        $body        = \GuzzleHttp\Psr7\stream_for(json_encode($request->request->all()));
        $psr7Request = $this->getPsr7Factory()->createRequest($request);
        $psr7Request = $psr7Request->withBody($body);
        return $psr7Request;
    }

    /**
     * @param Request $request
     * @return \Psr\Http\Message\ServerRequestInterface|\Zend\Diactoros\ServerRequest
     */
    public function fromHttpFoundationGETToPSR7(Request $request) {
        return $this->getPsr7Factory()->createRequest($request);
    }

    /**
     * @return DiactorosFactory
     */
    public function getPsr7Factory() {
        if (!$this->psr7Factory)
            $this->setPsr7Factory(new DiactorosFactory);
        return $this->psr7Factory;
    }

    /**
     * @param DiactorosFactory $psr7Factory
     * @return $this - Provides Fluent Interface
     */
    public function setPsr7Factory($psr7Factory) {
        $this->psr7Factory = $psr7Factory;
        return $this;
    }

    /**
     * @return HttpFoundationFactory
     */
    public function getHttpFoundationFactory() {
        if (!$this->httpFoundationFactory)
            $this->setHttpFoundationFactory(new HttpFoundationFactory);
        return $this->httpFoundationFactory;
    }

    /**
     * @param HttpFoundationFactory $httpFoundationFactory
     * @return $this - Provides Fluent Interface
     */
    public function setHttpFoundationFactory($httpFoundationFactory) {
        $this->httpFoundationFactory = $httpFoundationFactory;
        return $this;
    }

    /**
     * @return Client
     */
    public function getClient() {
        return $this->client;
    }

    /**
     * @param Client $client
     * @return $this - Provides Fluent Interface
     */
    public function setClient($client) {
        $this->client = $client;
        return $this;
    }

    /**
     * @param Request $request
     * @return string
     */
    public function getRequestFingerPrint(Request $request) {
        $data = [
            'base_url' => $request->getBaseUrl(),
            'uri'      => $request->getUri(),
            'params'   => $request->isMethod('GET') ? $request->query->all() : $request->request->all(),
            'method'   => $request->getMethod(),
        ];
        return md5(json_encode($data));
    }
}